<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simulateur Moto 3D Immersif</title>
<style>
body { margin:0; overflow:hidden; background:#87CEEB; }
canvas { display:block; }
#hud { position:absolute; top:10px; left:10px; color:white; font-family:Arial; font-size:18px; }
</style>
</head>
<body>
<div id="hud">Vitesse: 0 km/h | Distance: 0 m</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>

<script>
// ===== Scene, Camera, Renderer =====
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,5,10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===== Lights =====
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(10,20,10);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404040));

// ===== HUD =====
const hud = document.getElementById("hud");

// ===== Road with moving bands =====
const roadWidth = 6;
const roadLength = 1000;
const road = new THREE.Group();
scene.add(road);

// Road surface
const roadMat = new THREE.MeshStandardMaterial({color:0x333333});
const roadGeo = new THREE.PlaneGeometry(roadWidth,1000);
const roadMesh = new THREE.Mesh(roadGeo,roadMat);
roadMesh.rotation.x=-Math.PI/2;
roadMesh.position.z=-500;
road.add(roadMesh);

// White center lines
let lines = [];
for(let i=0;i<50;i++){
  const lineGeo = new THREE.PlaneGeometry(0.2,5);
  const lineMat = new THREE.MeshStandardMaterial({color:0xffffff});
  const line = new THREE.Mesh(lineGeo,lineMat);
  line.rotation.x=-Math.PI/2;
  line.position.z = -i*20;
  line.position.y=0.01;
  scene.add(line);
  lines.push(line);
}

// ===== Moto (cube + roues) =====
const bike = new THREE.Group();
const bodyGeo = new THREE.BoxGeometry(1,0.5,2);
const bodyMat = new THREE.MeshStandardMaterial({color:0xff0000});
const body = new THREE.Mesh(bodyGeo,bodyMat);
body.position.y=0.5;
bike.add(body);

// Roues
const wheelGeo = new THREE.CylinderGeometry(0.25,0.25,0.2,16);
const wheelMat = new THREE.MeshStandardMaterial({color:0x000000});
const wheelPositions = [
  [-0.4,0.25,0.8], [0.4,0.25,0.8],
  [-0.4,0.25,-0.8],[0.4,0.25,-0.8]
];
wheelPositions.forEach(p=>{
  const w = new THREE.Mesh(wheelGeo,wheelMat);
  w.rotation.z=Math.PI/2;
  w.position.set(...p);
  bike.add(w);
});
bike.position.y=0;
bike.position.z=0;
scene.add(bike);

// ===== Obstacles =====
let obstacles=[];
function spawnObstacle(){
  const types=['cone','car','barrier'];
  const type = types[Math.floor(Math.random()*types.length)];
  let obsGeo, obsMat;
  if(type==='cone'){
    obsGeo = new THREE.ConeGeometry(0.5,1,6);
    obsMat = new THREE.MeshStandardMaterial({color:0xffa500});
  } else if(type==='car'){
    obsGeo = new THREE.BoxGeometry(1,1,2);
    obsMat = new THREE.MeshStandardMaterial({color:0x0000ff});
  } else {
    obsGeo = new THREE.BoxGeometry(2,1,0.5);
    obsMat = new THREE.MeshStandardMaterial({color:0x800080});
  }
  const obs = new THREE.Mesh(obsGeo, obsMat);
  obs.position.x = (Math.random()-0.5)*(roadWidth-1);
  obs.position.y=0.5;
  obs.position.z = bike.position.z - 50;
  scene.add(obs);
  obstacles.push(obs);
}

// ===== Controls =====
let left=false,right=false,forward=false;
let speed=0,maxSpeed=0.5,distance=0;

document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') left=true;
  if(e.key==='ArrowRight') right=true;
  if(e.key==='ArrowUp') forward=true;
});
document.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft') left=false;
  if(e.key==='ArrowRight') right=false;
  if(e.key==='ArrowUp') forward=false;
});

// Touch controls
let touchStartX=null;
document.addEventListener('touchstart', e=>{
  touchStartX = e.touches[0].clientX;
  forward = true;
});
document.addEventListener('touchmove', e=>{
  const touchX = e.touches[0].clientX;
  if(touchX < touchStartX) left=true,right=false;
  else if(touchX > touchStartX) right=true,left=false;
});
document.addEventListener('touchend', e=>{
  left=false; right=false;
});

// ===== Animate =====
function animate(){
  requestAnimationFrame(animate);

  // Accélération
  if(forward) speed += 0.001;
  speed = Math.min(speed,maxSpeed);
  distance += speed*10;

  // Virage
  if(left) bike.rotation.y += 0.03;
  if(right) bike.rotation.y -= 0.03;

  // Déplacement
  bike.position.x -= Math.sin(bike.rotation.y)*speed*50;
  bike.position.z -= Math.cos(bike.rotation.y)*speed*50;

  // Caméra
  camera.position.x = bike.position.x - Math.sin(bike.rotation.y)*10;
  camera.position.z = bike.position.z - Math.cos(bike.rotation.y)*10;
  camera.position.y = bike.position.y + 5;
  camera.lookAt(bike.position);

  // Défilement des bandes
  lines.forEach(line=>{
    line.position.z += speed*50;
    if(line.position.z > bike.position.z + 10){
      line.position.z -= 1000;
    }
  });

  // Obstacles
  obstacles.forEach((obs,i)=>{
    obs.position.z += speed*50;
    if(obs.position.z > bike.position.z + 5){
      scene.remove(obs);
      obstacles.splice(i,1);
    }
    const dx = Math.abs(obs.position.x - bike.position.x);
    const dz = Math.abs(obs.position.z - bike.position.z);
    if(dx<1 && dz<1){
      alert("Game Over! Distance: "+Math.floor(distance)+" m");
      location.reload();
    }
  });

  hud.textContent = `Vitesse: ${Math.floor(speed*200)} km/h | Distance: ${Math.floor(distance)} m`;

  renderer.render(scene,camera);
}

// Spawn obstacles toutes les 2 sec
setInterval(spawnObstacle,2000);

// Lancer animation
animate();

// ===== Responsive =====
window.addEventListener('resize', ()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
